
import Test.QuickCheck

-- 1. Three positive integer values (x, y, z) are a Phytagoran triple if x2+y2=z2, that is to say, if they correspond to lengths for sides of a triangle.
-- a) Define a function to test whether three values are a Phytagorean triple. For instance:


isTriple :: Integer -> Integer -> Integer -> Bool
-- isTriple z x y = x²+y² == z²
isTriple x y z = (x^2)+(y^2) == z^2

-- b) For any x and y positive integers such that x>y, triple (x2-y2, 2xy, x2+y2) is Phytagorean. Accordingly,write a function named taking two numbers and returning a Phytagorean triple. For instance:

triple x y = if x > y 
  then (x^2-y^2, 2*x*y, x^2+y^2)
  else error "Unable to do triple"

-- c) Read and understand the following property, that states that all triples generated by function are Phytagorean:
p_triples x y = x>0 && y > 0 && x>y ==> isTriple l1 l2 h
 where
     (l1, l2, h) = triple x y


-- d) Check this property using QuickCheck (recall to import at the beginning of your program and to copy the property into your file). You should observe a result similar to the following one:

-- quickCheck p_triples

-- Which means that, although only 62 test cases fulfilling the precondition where generated by
-- QuickCheck, all of them passed the test.

-- if not found --> cabal install QuickCheck
-- <no location info>: error:
--     Could not find module ‘Test.QuickCheck’
--     It is not a module in the current program, or in any known package.


-- 2. Define a polymorphic function for swapping components in a two components tuple:

swap:: (a, b) -> (b, a)
swap (a, b) = (b, a)


-- 3. This exercise is on sorting tuples.
-- a) Define an overloaded function for ordered types taking a two components tuple (whose elements have the same type) and returning the corresponding ascending sorted tuple:

sort2 :: Ord a => (a,a) -> (a,a)
sort2 (x,y) = if x <= y
    then (x,y)
    else (y, x)
-- b) Copy the following properties for function

p1_sort2 x y = sorted (sort2 (x,y))
    where sorted (x,y) = x <= y

p2_sort2 x y = sameElements (x, y) (sort2 (x,y))
    where
        sameElements (x, y) (x', y') = (x == x' && y == y') || (x == y' && y == x')

-- Understand each of these properties and test them using QuickCheck.
-- quickCheck p1_sort2
-- +++ OK, passed 100 tests.
 
-- quickCheck p2_sort2
-- +++ OK, passed 100 tests.


-- c) Define an overloaded function taking a tuple with three components of the same type and returning it sorted in ascending order:


-- We can implement this with quicksort (this would sort n elements not only 3)
quicksort:: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallsort = quicksort [a | a <- xs, a <= x]
        bigsort = quicksort [a | a <- xs, a > x]
    in smallsort ++ [x] ++ bigsort


-- But how I think we are supposed to do it according to b) (Unrolled Bubble sort)
-- Using guards

sort3:: Ord a => (a,a,a) -> (a,a,a)
sort3 (x, y, z)
     | x > y = sort3(y, x, z)
     | y > z = sort3(x, z, y)
     | x > z = sort3(z, y, x)
     | otherwise = (x, y, z)


-- d) Write similar properties to the ones in paragraph b) but for QuickCheck.

p1_sort3 x y z = sorted (sort3 (x,y,z))
    where sorted (x,y,z) = x <= y && y <= z

p2_sort3 x y z = sameElements (x, y, z) (sort3 (x,y,z))
    where
        sameElements (x,y, z) (x', y', z') = (x == x' && y == y' && z == z') || (x == y' && y == x' && x == z')

-- All tests passed for both


-- 4. Although there already exists a predefined function (a function, and test them using) returnin the maximum of two values, in this exercise you will define your own version.

-- a) As it is not allowed to define a function whose name coincides with a predefine done, define a function such that:

max2 :: Ord a => a -> a -> a
max2 x y
    | x <= y    = y
    | otherwise = x

--  b) Define the following properties that function should fulfill and test them using QuickCheck (recall to import at the beginning of your program):
--  i.: p1_max2 maximum of x and y is either x or either y.
--  ii.: p2_max2 maximum of x and y is greater than or equal to x and greater or equal than y.
--  iii.: p3_max2 if x is greater than or equal to y, then maximum of x and y is x.
--  iv.: p4_max2 if y is greater than or equal to x, then maximum of x and y is y.

p1_max2 x y = max2 x y == x || max x y == y 
p2_max2 x y = max2 x y >= y || max x y >= x
p3_max2 x y | x >= y    =  max2 x y == x
p4_max2 x y | y >= x    =  max2 x y == y

-- All tests passed

--  5. Define an overloaded function for ordered types taking a value x and a tuple with two components (max,min) and testing whether x is in the interval determined by min and max, i.e., if x ∈ [min,max]. For instance:

between :: Ord a => a -> (a,a) -> Bool
between x (y, z) = (x >= y && x <= z)


-- 6. Define an overloaded function for types with equality taking a tuple with three components of the same type and returning True if all of them are equal. For instance:

equals3 :: Eq a => (a, a, a) -> Bool
equals3 (x, y, z) = x == y && x  == z


-- 7. Recall that the quotient and the modulo for an integer division can be calculated by using predefined functions div and mod

-- a) Define a function named decompose taking an integer value representing seconds, and returning a three components tuple with corresponding hours, minutes and seconds, so that returned minutes and seconds are in the range 0 to 59. For instance:
-- Define this function by filling in the following outline:
type Hour = Integer
type Minute = Integer
type Second = Integer
decompose :: Second -> (Hour, Minute, Second)
decompose x = (hours, minutes, seconds)
    where 
        hours = mod (div x 3600) 60 
        minutes = mod (div x 60) 60 
        seconds = mod x 60

-- b) Read and test the following property in order to check correctness for your function:
p_decompose x = x >= 0 ==> h*3600 + m*60 + s == x
                             && between m (0,59)
                             && between s (0, 59)
     where (h, m, s) = decompose x



-- 8. Let us consider the following definition to represent that one euro is 166.386 pesetas:

oneEuro :: Double
oneEuro = 166.386

-- a) Define a function named changing an amount of pesetas (expressed as a) into corresponding amount of euros. For instance:

pesetasToEuros :: Double -> Double 
pesetasToEuros x =x/oneEuro

--b) Define a function named changing euros into pesetas. For instance:

eurosToPesetas :: Double -> Double
eurosToPesetas x = x * oneEuro

-- c) Let us consider the following property, stating that by changing pesetas into euros and then changing back those euros into pesetas, we should obtain the original amount of pesetas (i.e., those are inverse functions): Test this property with QuickCheck and check that it does not hold. Why? (hint: these functions are defined on floating point numbers).

p_inverse x = eurosToPesetas (pesetasToEuros x) == x

-- Because some decimals are lost, it is not exactly equal, this will be fixed in the next exercise

-- 9. Let us consider the following operator to test whether two values are approximately equal: For instance: Copy this operator definition into your file, and restate property p_inverse so that it holds. Test that your new definition for the property does indeed hold using QuickCheck.

infix 4 ~=
(~=) :: Double -> Double -> Bool
x ~= y = abs (x-y) < epsilon
    where epsilon = 1/1000


p_inverse' x = eurosToPesetas (pesetasToEuros x) ~= x

-- 10. Let us consider the quadratic equation ax2 + bx + c = 0.
-- a) Define a function named roots taking three arguments (corresponding to equation coefficients a, b and c) and returning a tuple with two real solutions to the equation (you can use predefined function in order to compute the square root of a floating number). Recall that the discriminant is defined as b2-4ac and that a quadratic equation has real solutions if the corresponding discriminant is non-negative. For instance:

-- roots 1 (-2) 1.0 => (1.0, 1.0)
-- roots 1.0 2 4 => Exception: Non real roots

-- ax² + bx + c = 0
roots :: Double -> Double -> Double -> (Double, Double) 
roots a b c
    | sqrteq >= 0     = ((-b + sqrt sqrteq )/ (2*a), (-b - sqrt sqrteq) / (2*a)) 
    | otherwise             = error "Non real roots"
    where sqrteq = b^2 - 4*a*c

-- b) Let us consider the following property to test that values returned by
--equation:

p1_roots a b c = isRoot r1 && isRoot r2
    where
        (r1, r2) = roots a b c
        isRoot r = a * r^2 + b*r + c ~= 0


--Test this property using QuickCheck and check that it fails. Find out the reason, and add appropriate preconditions so that it does not fail by filling in interrogations in the following outline:

p2_roots a b c = ((((b)^2 - 4*(a)*(c)) >= 0) && (a /= 0)) ==> isRoot r1 && isRoot r2
    where 
        (r1, r2) = roots a b c
        isRoot r = a*r^2 + b*r +c ~= 0

--so that:
-- quickCheck p2_roots
-- +++ Ok, passed 100 tests



--11. Define an overloaded function named and returning over integral numbers taking to values x and y, if x is a multiple of y. For example:

-- isMultiple 9 3 => True
-- isMultiple 7 3 => False

isMultiple :: Integer -> Integer -> Bool
isMultiple x y = mod x y == 0

-- 12. Define a left associative logical implication operator so that its precedence is lower than the one corresponding to conjunction and disjunction operators:
-- 3 < 1 ==>> 4 > 2
--Hint: you can directly define it using a single equation:
--Or you can define it by using multiple equations and patterns:

--(==>>) :: Bool -> Bool -> Bool
-- (p→q)→r (left associativity???)
infix 4 ==>>
(==>>) :: Bool -> Bool -> Bool
True  ==>> y = y
False ==>> y = True 


-- 13. Leap years are those which are multiple of 4. One exception to the rule are those years that are multiples of 100, which are only considered leap if they are additionally multiple of 400. Define a function named taking a year and returning if it is a leap year. For example:

--Hint: use the logical implication operator defined in previous exercise in order to represent the following sentence: “n is a leap year if it fulfills the following two conditions: (a) it is a multiple of 4, and (b) if n is a multiple of 100 then n should be a multiple of 400”.

leapYear :: Integer -> Bool
leapYear x = isMultiple x 4 && isMultiple x 100 ==>> isMultiple x 400




-- 14. Although there already exists a predefined operator ( ) in Haskell to compute raising of a number to a power, the aim of this exercise is that you define your own version of this operator. 
-- a) By using the following property bn = b ∙ bn-1 define a recursive function taking an integer b and a natural exponent n and returning bn. Forexample:
-- power 2 3 => 8

power :: Integer -> Integer -> Integer
power x 0 = 1
power x y | y>0 = x * power x (y-1)
power x y = error "Negative Exponent" 

--b) Let us now consider the following property:
--𝑏^𝑛 = { (𝑏^𝑛/2)²       if 𝑛 is even }
--      {   𝑏 ˑ 𝑏^𝑛−1     if 𝑛 is odd }

--Turn this property into a new recursive definition, and accordingly, define a recursive
--function taking an integer b and a natural exponent n and returning bn (don’t use previous
--function in your new definition). For example:

-- power' 2 3 => 8          power' 2 4 => 16

power' :: Integer -> Integer -> Integer
power' b n
    |  mod n 2 == 0     = ((b)^(div n 2))^2
    |  otherwise        = b * power' b (n-1) 


-- c) Test using QuickCheck correctness of both functions by means of the following property:

p_power b n = n >= 0 ==> power b n == sol && power' b n == sol
     where sol = b ^ n

--d) Assuming that doing a square operation corresponds to a doing product, determine the number of products that both functions do in order to raise some base to an exponent n.
--Hint: in order to analyze efficiency for function, consider first exponents that are power of 2.

-- 2³ = power 2 (power 2 (power 2 (1))) 
-- 2⁵ = 2 * 2 * 2 * 2 * 2

-- It will be O(n) efficient


--15. For a set whose elements are all different, a permutation of it is each possible rearrangement of its elements. For instance, for set {1,2,3}, there exists 6 different permutations of its elements: {1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,1,2} y {3,2,1}. For a set with n elements, the number of permutations is the factorial of n (usually written as n!), and defined as the product of natural numbers from 1 to n. Define a function taking a natural number and returning its factorial. As factorial function grows very quickly, use type in order to avoid overflows. For instance:

factorial :: Integer -> Integer
factorial 1 = 1
factorial x = x * factorial (x-1)


--16. This exercise studies integer division of numbers.
--a) Define function taking two numbers and testing whether its first argument exactly divides its second one. For instance:

divides :: Integer -> Integer -> Bool
divides x y = mod y x == 0


--b) Read, understand and test using QuickCheck the following property for
--function:

p1_divides x y = y/= 0 && y `divides` x ==> div x y * y == x
-- +++ OK, passed 100 tests; 904 discarded.


-- c) Define a property to test using QuickCheck that if a number exactly divides two numbers, it also exactly divides their sum.

p2_divides x y z = (x /= 0 && y/=0 && z/=0 && divides x y && divides x z) ==> divides x (y+z) == True

-- *** Gave up! Passed only 52 tests; 1000 discarded tests.


--17. The median of a set of numbers is the value for which half the numbers are larger and half are smaller. Define a function to compute the median for a tuple with 5 components so that, for instance, Observe that 1,3 ≤ 10 ≤ 20,50. According to this observation, define this function using guards by filling in the following outline:


median :: Ord a => (a, a, a, a, a) -> a
median (x, y, z, t, u)
    | x > z              = median (z, y, x, t, u)
    | y > z              = median (x, z, y, t, u)
    | u < z              = median (x, y, u, t, z)
    | t < z              = median (x, y, t, z, u)
    | otherwise          = z 







